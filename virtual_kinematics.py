# ==========================================
# 1. å¯¼å…¥å·¥å…·åŒ… (ç›¸å½“äºæŠŠå·¥å…·ç®±æ‹¿è¿‡æ¥)
# ==========================================

# å¯¼å…¥æœºå™¨äººå·¥å…·ç®± (æ ¸å¿ƒå¤§è„‘ï¼Œè´Ÿè´£å»ºæ¨¡å’Œè§£ç®—)
import roboticstoolbox as rtb

# å¯¼å…¥ç©ºé—´æ•°å­¦åº“ (è´Ÿè´£å¤„ç† 3D æ—‹è½¬ã€åæ ‡å˜æ¢ã€çŸ©é˜µä¹˜æ³•)
import spatialmath as sm

# å¯¼å…¥ NumPy æ•°å­¦åº“ (ç®€ç§° npï¼Œè´Ÿè´£ç®— sin/cosã€ç®¡ç†æ•°ç»„)
import numpy as np

# å¯¼å…¥ç»˜å›¾åº“ Matplotlib (è´Ÿè´£ç”»å›¾ã€å¼¹çª—)
import matplotlib

# å¼ºåˆ¶è®¾ç½®ç»˜å›¾åå°ä¸º 'TkAgg'ã€‚
# Windows ç³»ç»Ÿä¸‹é»˜è®¤åå°æœ‰æ—¶ä¼šå¡æ­»ï¼ŒTkAgg æ˜¯æœ€ç¨³å®šã€æœ€å¬è¯çš„è€ç‰Œåå°ã€‚
matplotlib.use('TkAgg') 

# å¯¼å…¥ Matplotlib çš„ç»˜å›¾æ¨¡å— (ç®€ç§° plt)
import matplotlib.pyplot as plt


# ==========================================
# 2. ç¯å¢ƒåˆå§‹åŒ– (æŠŠæœºå™¨äººæ¬è¿›ç”µè„‘)
# ==========================================
print("â³ æ­£åœ¨åŠ è½½æœºå™¨äººæ¨¡å‹...")

# å®šä¹‰ URDF æ–‡ä»¶çš„è·¯å¾„ (è¿™æ˜¯æœºå™¨äººçš„èº«ä»½è¯ï¼Œæè¿°äº†å®ƒé•¿ä»€ä¹ˆæ ·ã€èƒ³è†Šæœ‰å¤šé•¿)
# æ³¨æ„ï¼šWindows è·¯å¾„è¦ç”¨åŒåæ–œæ  \\ é˜²æ­¢è½¬ä¹‰é”™è¯¯
urdf_path = "C:\\Users\\kang\\Documents\\VSCode\\Lerobot\\so101_new_calib.urdf"

# ä» URDF æ–‡ä»¶åŠ è½½æœºå™¨äººæ¨¡å‹ï¼Œå­˜å…¥ raw_robot å˜é‡
raw_robot = rtb.ERobot.URDF(urdf_path)
print(f"âœ… æ¨¡å‹åŠ è½½æˆåŠŸ: {raw_robot.name}")

# å°è¯•æå–æœºå™¨äººçš„â€œè¿åŠ¨é“¾â€ (Kinematic Chain)
# ä¹Ÿå°±æ˜¯ä»â€œåº•åº§â€åˆ°â€œå¤¹çˆªä¸­å¿ƒâ€çš„é‚£ä¸€æ¡çº¿ï¼Œå¿½ç•¥å…¶ä»–æ— å…³çš„é›¶ä»¶
try:
    # å‘Šè¯‰ç”µè„‘ï¼šæˆ‘åªå…³å¿ƒåˆ° "gripper_frame_link" (å¤¹çˆªæœ«ç«¯) çš„è¿åŠ¨
    robot_ets = raw_robot.ets(end="gripper_frame_link")
except:
    # å¦‚æœæ‰¾ä¸åˆ°åå­—ï¼Œå°±è‡ªåŠ¨æå–ä¸€æ¡ä¸»é“¾
    robot_ets = raw_robot.ets()


# ==========================================
# 3. è§„åˆ’ 8 å­—è½¨è¿¹ (æ ¸å¿ƒé€»è¾‘)
# ==========================================

# --- A. å¯»æ‰¾ä¸€ä¸ªâ€œèˆ’é€‚å§¿æ€â€ (é˜²æ­¢å§¿æ€æ­»é”) ---

# å®šä¹‰ä¸€ç»„å…³èŠ‚è§’åº¦ï¼Œè®©æœºå™¨äººæ‘†å‡ºä¸€ä¸ªèˆ’æœçš„å§¿åŠ¿
# è¿™é‡Œçš„ 5 ä¸ªæ•°å­—åˆ†åˆ«å¯¹åº” 5 ä¸ªç”µæœºçš„å¼§åº¦ï¼š
# [åº•åº§0åº¦, å¤§è‡‚åä»°, è‚˜éƒ¨å‰å‹, æ‰‹è…•ä¸‹å‹, å¤¹çˆª0åº¦]
# ç»éªŒå€¼
q_home = np.array([0.0, -0.6, 1.2, -0.6, 0.0]) 

# ä½¿ç”¨ fkine (æ­£è¿åŠ¨å­¦) ç®—å‡ºè¿™ä¸ªèˆ’æœå§¿åŠ¿çš„ 3D åæ ‡å’Œæ—‹è½¬
# sm.SE3(...) æ˜¯æŠŠè®¡ç®—ç»“æœè½¬æ¢æˆä¸€ä¸ªæ ‡å‡†çš„æ™ºèƒ½çŸ©é˜µå¯¹è±¡
T_home = sm.SE3(robot_ets.eval(q_home))

# ä»è¿™ä¸ªçŸ©é˜µä¸­æå–å‡ºâ€œæ—‹è½¬éƒ¨åˆ†â€ (.R å±æ€§)
# æ„æ€æ˜¯ï¼šæ—¢ç„¶è¿™ä¸ªå§¿åŠ¿å¾ˆèˆ’æœï¼Œé‚£æˆ‘ä»¬å°±è®°ä¸‹æ­¤æ—¶æ‰‹æŒçš„æœå‘ï¼Œä¸€ä¼šå„¿ç”»å›¾å…¨ç¨‹ä¿æŒè¿™ä¸ªæœå‘
comfortable_orientation = T_home.R 


# --- B. å®šä¹‰ 8 å­—è½¨è¿¹çš„å‚æ•° ---

# å®šä¹‰ 8 å­—çš„ä¸­å¿ƒç‚¹åæ ‡ [x, y, z]
# T_home.t[0] æ˜¯èˆ’æœå§¿åŠ¿çš„ X åæ ‡ï¼Œæˆ‘ä»¬ +0.05 ç±³ï¼Œè®©å®ƒç¨å¾®å¾€å‰ä¼¸ä¸€ç‚¹
# T_home.t[2] æ˜¯èˆ’æœå§¿åŠ¿çš„é«˜åº¦ï¼Œä¿æŒä¸å˜
center_pos = np.array([T_home.t[0] + 0.05, 0.0, T_home.t[2]]) 

# å®šä¹‰ 8 å­—çš„åŠå¾„ (0.05ç±³ = 5å˜ç±³)
radius = 0.05 

# å®šä¹‰æˆ‘ä»¬è¦æŠŠè¿™ä¸ª 8 å­—åˆ‡æˆå¤šå°‘æ­¥æ¥èµ° (60æ­¥)
steps = 60    

print(f"ğŸ“ ç›®æ ‡ä¸­å¿ƒ: {center_pos}")
print(f"ğŸ§­ é”å®šèˆ’é€‚å§¿æ€ (ä½¿ç”¨æå–å‡ºçš„æ—‹è½¬çŸ©é˜µ)")
print(f"ğŸš€ å¼€å§‹ IK (é€†è¿åŠ¨å­¦) è§£ç®— {steps} æ­¥...")


# --- C. å¼€å§‹å¾ªç¯è®¡ç®—æ¯ä¸€æ­¥ ---

# åˆ›å»ºä¸€ä¸ªç©ºåˆ—è¡¨ï¼Œç”¨æ¥å­˜æ”¾ç®—å‡ºæ¥çš„æ‰€æœ‰å…³èŠ‚è§’åº¦
q_trajectory = []

# è®¾ç½®åˆå§‹çŒœæµ‹å€¼ã€‚å‘Šè¯‰ç”µè„‘ï¼šâ€œç¬¬ä¸€æ­¥çš„è§£ï¼Œè‚¯å®šç¦» q_home ä¸è¿œï¼Œä»è¿™é‡Œå¼€å§‹æ‰¾â€
last_q = q_home 

# np.linspace ç”Ÿæˆæ—¶é—´åºåˆ—ï¼šä» 0 åˆ° 2Ï€ (ä¸€ä¸ªåœ†å‘¨)ï¼Œåˆ‡æˆ 60 ä»½
t_array = np.linspace(0, 2 * np.pi, steps)

# è®¡æ•°å™¨ï¼Œè®°å½•æˆåŠŸç®—å‡ºäº†å¤šå°‘æ­¥
success_count = 0

# éå†æ¯ä¸€ä¸ªæ—¶é—´ç‚¹ t
for t in t_array:
    # --- 1. è®¡ç®—ç›®æ ‡ä½ç½® XYZ (æ•°å­¦å‚æ•°æ–¹ç¨‹) ---
    x = center_pos[0] + radius * np.cos(t)                # X è½´åæ ‡ (ä½™å¼¦æ³¢)
    y = center_pos[1] + radius * np.sin(2 * t) / 2.0      # Y è½´åæ ‡ (2å€é¢‘æ­£å¼¦æ³¢ï¼Œäº§ç”Ÿäº¤å‰)
    z = center_pos[2]                                     # Z è½´åæ ‡ (é«˜åº¦ä¸å˜)
    
    # --- 2. ç»„è£…ç›®æ ‡ä½å§¿çŸ©é˜µ T ---
    # sm.SE3.Rt æ˜¯ä¸€ä¸ªå·¥å‚å‡½æ•°ï¼š
    # è¾“å…¥ï¼šcomfortable_orientation (åˆšæ‰å·æ¥çš„æ—‹è½¬çŸ©é˜µ R)
    # è¾“å…¥ï¼št=[x,y,z] (åˆšæ‰ç®—å‡ºçš„ä½ç½®å‘é‡ t)
    # è¾“å‡ºï¼šä¸€ä¸ªæ ‡å‡†çš„ 4x4 é½æ¬¡å˜æ¢çŸ©é˜µ
    # ä¿è¯äº†æ‰‹æŒæœå‘ä¸å˜
    T_target = sm.SE3.Rt(comfortable_orientation, t=[x, y, z])
    
    # --- 3. é€†è¿åŠ¨å­¦è§£ç®— (IK) ---
    # robot_ets.ikine_LM: ä½¿ç”¨ Levenberg-Marquardt ç®—æ³•æ±‚è§£
    # q0=last_q: ä½¿ç”¨ä¸Šä¸€æ­¥çš„ç»“æœä½œä¸ºè¿™ä¸€æ­¥çš„èµ·ç‚¹ (è¿è´¯æ€§)
    # mask=[1, 1, 1, 1, 1, 0]: é‡è¦ï¼å‘Šè¯‰æ±‚è§£å™¨å¿½ç•¥ç¬¬6ä¸ªè‡ªç”±åº¦(Yawæ—‹è½¬)ï¼Œå› ä¸ºSO-100åšä¸åˆ°
    sol = robot_ets.ikine_LM(T_target, q0=last_q, mask=[1, 1, 1, 1, 1, 0])
    
    # å¦‚æœè§£ç®—æˆåŠŸ (success ä¸º True)
    if sol.success:
        # sol.q åªæœ‰ 5 ä¸ªæ•°ï¼Œæˆ‘ä»¬è¡¥ä¸€ä¸ª 0 (ä»£è¡¨å¤¹çˆª) å‡‘æˆ 6 ä¸ªæ•°
        q_full = np.append(sol.q, 0) 
        
        # æŠŠè¿™ä¸€å¸§çš„ 6 ä¸ªè§’åº¦å­˜å…¥åˆ—è¡¨
        q_trajectory.append(q_full)
        
        # æ›´æ–° last_qï¼Œä¸‹ä¸€æ­¥è§£ç®—æ—¶å°±ç”¨å½“å‰è¿™ä¸ªç»“æœåšèµ·ç‚¹
        last_q = sol.q 
        success_count += 1
    else:
        # å¦‚æœè§£ç®—å¤±è´¥ (é€šå¸¸ä¸ä¼šå‘ç”Ÿäº†)ï¼Œå°±æ²¿ç”¨ä¸Šä¸€æ­¥çš„è§’åº¦ï¼Œé˜²æ­¢ç¨‹åºå´©æºƒ
        if len(q_trajectory) > 0:
            q_trajectory.append(q_trajectory[-1])
        else:
            q_trajectory.append(np.append(last_q, 0))

# æ‰“å°è§£ç®—ç»“æœç»Ÿè®¡
print(f"ğŸ“Š è§£ç®—å®Œæˆã€‚æˆåŠŸç‡: {success_count}/{steps} ({(success_count/steps)*100:.1f}%)")


# ==========================================
# 4. å¯è§†åŒ– (æ’­æ”¾åŠ¨ç”»)
# ==========================================
print("ğŸ¥ å¯åŠ¨åŠ¨ç”»çª—å£...")

# å®ä¾‹åŒ– PyPlot ç»˜å›¾åç«¯ (æ­å»ºèˆå°)
env = rtb.backends.PyPlot.PyPlot()

# å¯åŠ¨çª—å£ï¼Œæ ‡é¢˜å« "SO-100..."
env.launch("SO-100 Cartesian IK Demo")

# æŠŠæœºå™¨äººæ¨¡å‹æ·»åŠ åˆ°èˆå°ä¸Š
env.add(raw_robot)

# åˆ›å»ºä¸‰ä¸ªç©ºåˆ—è¡¨ï¼Œç”¨æ¥å­˜çº¢è‰²è½¨è¿¹çº¿çš„åæ ‡
path_x, path_y, path_z = [], [], []

try:
    # è¿™æ˜¯ä¸€ä¸ªæ­»å¾ªç¯ï¼Œè®©åŠ¨ç”»ä¸€ç›´æ’­æ”¾ï¼Œç›´åˆ°ä½ æŒ‰ Ctrl+C
    while True:
        # éå†åˆšæ‰ç®—å¥½çš„è½¨è¿¹åˆ—è¡¨
        for q in q_trajectory:
            # --- 1. æ›´æ–°æœºå™¨äººå§¿æ€ ---
            raw_robot.q = q
            
            # --- 2. è®°å½•è½¨è¿¹ (ä¸ºäº†ç”»çº¢çº¿) ---
            #fkine(q) æ­£å‘è§£ç®—ï¼šæ ¹æ®å½“å‰è§’åº¦ï¼Œç®—å‡ºæŒ‡å°–ç°åœ¨åœ¨å“ª
            T_current = raw_robot.fkine(q)
            
            # æŠŠ XYZ åæ ‡åˆ†åˆ«å­˜å…¥åˆ—è¡¨
            path_x.append(T_current.t[0])
            path_y.append(T_current.t[1])
            path_z.append(T_current.t[2])
            
            # é™åˆ¶åˆ—è¡¨é•¿åº¦ï¼šå¦‚æœè¶…è¿‡60ä¸ªç‚¹ï¼Œå°±åˆ æ‰æœ€æ—©çš„ä¸€ä¸ª
            # è¿™æ ·çº¢çº¿å°±ä¸ä¼šæ— é™å˜é•¿ï¼Œè€Œæ˜¯åƒè´ªåƒè›‡ä¸€æ ·
            if len(path_x) > steps:
                path_x.pop(0); path_y.pop(0); path_z.pop(0)
            
            # --- 3. ç»˜åˆ¶çº¢è‰²è½¨è¿¹çº¿ ---
            # å¦‚æœåˆ—è¡¨é‡Œè‡³å°‘æœ‰2ä¸ªç‚¹ (2ç‚¹æˆçº¿)
            if len(path_x) > 1:
                # å¦‚æœä¹‹å‰ç”»è¿‡çº¿ï¼Œå…ˆæŠŠå®ƒåˆ æ‰ (é˜²æ­¢é‡å½±)
                if hasattr(env, 'line_ref'):
                    env.line_ref.remove()
                
                # ç”»æ–°çº¿ï¼šx,y,zåæ ‡ï¼Œ'r-'è¡¨ç¤ºçº¢è‰²å®çº¿ï¼Œçº¿å®½2
                lines = env.ax.plot(path_x, path_y, path_z, 'r-', linewidth=2)
                
                # ä¿å­˜è¿™æ¬¡ç”»çš„çº¿ï¼Œæ–¹ä¾¿ä¸‹ä¸€å¸§åˆ é™¤
                env.line_ref = lines[0]

            # --- 4. åˆ·æ–°ç”»é¢ ---
            # æš‚åœ 0.05 ç§’ï¼Œè®©è‚‰çœ¼èƒ½è·Ÿä¸Šé€Ÿåº¦ï¼ŒåŒæ—¶è®©çª—å£å“åº”é¼ æ ‡æ“ä½œ
            env.step(0.05)
            
        # æ’­å®Œä¸€è½®ï¼Œæ¸…ç©ºè½¨è¿¹åˆ—è¡¨ï¼Œå‡†å¤‡ä¸‹ä¸€è½®é‡ç”»
        path_x.clear(); path_y.clear(); path_z.clear()
        
except KeyboardInterrupt:
    print("åœæ­¢æ’­æ”¾")